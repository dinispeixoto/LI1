module Main where 

import Data.Char
import Data.List


type Tabuleiro = [String]
type Orientacao = Float
type Posicao = (Int,Int,Int,Orientacao)
type Comandos = String

type Lampada = (Int,Int)
type Jogadas = Int

type Coords = String
type Tipo = String
type Cubo = String

main = do input <- getContents
          putStrLn (unlines (createFile (lines (input))))

-- ##################################################### FICHEIRO XHTML #######################################################################
{-
createFile :: [String] -> [String]
createFile input = let tab = take (length input-2) input
                       (x,y,z,ori) = getPos tab (input !! (length input-2))
                       cmd = input !! (length input-1)
                       lamps = getLamps (reverse tab) 0

                       sequence = (showPos (x,y,z,ori),'_'):(execCmds tab (x,y,z,ori) cmd lamps 0)
                       --construir tabuleiro
                       cells = transformTab (reverse tab) 0
                       --controlo de tempo da animação
                       nCMD = length sequence - 1
                       seconds = nCMD + 2
                       duration = (fromIntegral nCMD) / (fromIntegral seconds)
                       intervalo = duration / (fromIntegral nCMD)
                       
                       timer = "<timeSensor DEF=\"time\" cycleInterval=\""++(show seconds)++"\" loop=\"true\"> </timeSensor>"

                       posKeys = unwords (getPosKeys sequence 0 intervalo)
                       posValues = unwords (getPosValues sequence)
                       posInterpolator = "<PositionInterpolator DEF=\"move\" key=\""++posKeys++"\" keyValue=\""++posValues++"\"> </PositionInterpolator>"



                    in []
-}

-- ########################################################### TABULEIRO #################################################################################

transformTab :: Tabuleiro -> Int -> [String] -> [Cubo]
transformTab [] _ _ = []
transformTab (l:ls) n = transformLn l (n,0) ++ transformTab ls (n+1)

transformLn :: String -> (Int,Int) -> [String] -> [Cubo]
transformLn [] _ _ = []
transformLn (c:cs) (n,m) | elem (coords (succ c) n m)  = ("<Transform translation=\"" ++ (coords c n m) ++ "\"> <Shape> <Appearance> <Material DEF=\"" ++ (unwords [show m, show n]) ++ "\" diffuseColor=\"0 0 1\"/> </Appearance><box size=\".98 .98 .98\"/></Shape></Transform>") : (lowerCubes (pred (toLower c)) n m) ++ transformLn cs (n,m+1) 
                                 | isUpper c = ("<Transform translation=\"" ++ (coords (toLower c) n m) ++ "\"> <Shape> <Appearance> <Material DEF=\"" ++ (unwords [show m, show n]) ++ "\" diffuseColor=\"0 1 1\"/> </Appearance><box size=\".98 .98 .98\"/></Shape></Transform>") : (lowerCubes (pred (toLower c)) n m) ++ transformLn cs (n,m+1) 
                                 | otherwise = getCube (coords c n m) : (lowerCubes (pred c) n m) ++ transformLn cs (n,m+1)


getCube :: Coords -> Cubo
getCube coord = "<Transform translation=\'" ++ coord ++ "\'> <Shape USE=\"tile\"/> </Transform>"

coords :: Char -> Int -> Int -> String
coords c n m = unwords [show m, show n, show (ord c - ord 'a')]


lowerCubes :: Char -> Int -> Int -> [String]
lowerCubes '`' _ _ = []
lowerCubes  c  n m = [getCube (coords c n m)] ++ lowerCubes (pred c) n m

-- ############################################################ POSIÇÕES ###########################################################################

getPosKeys :: [(String,Char)] -> Float -> Float -> [String]
getPosKeys [] _ _ = []
getPosKeys ((pos,cmd):t) time intervalo | cmd == '1' || cmd == '2' = show (time+intervalo/2) : (show (time+intervalo)) : getPosKeys t (time+intervalo) intervalo
                                        | cmd == '_' = show time: getPosKeys t time intervalo
                                        | cmd == 'S' = show (time+intervalo/3) : (show (time+2*intervalo/3)) : (show (time+intervalo)): getPosKeys t (time+intervalo) intervalo 
                                        | otherwise = show (time+intervalo) : getPosKeys t (time+intervalo) intervalo

getPosValues :: [(String,Char)] -> [String]
getPosValues (_:[]) = [] 
getPosValues ((pos1,'_'):(pos2,cmd2):t) =  pos1 : getPosValues ((pos1,' '):(pos2,cmd2):t)

getPosValues ((pos1,cmd1):(pos2,'1'):t) = let [x1,y1,z1] = map (\ n -> read n :: Float) (words pos1)
                                              [x2,y2,z2] = map (\ n -> read n :: Float) (words pos2)
                                              
                                              [vx,vy,vz] = [x2-x1, y2-y1, z2-z1]
       
                                          in unwords [show (x1+0.5*vx), show (y1+0.5*vy), show z1] : pos1 : getPosValues ((pos1,cmd1):t)


getPosValues ((pos1,cmd1):(pos2,'2'):t) = let [x,y,z] = map (\ n -> read n :: Float) (words pos1)
                                              
                                        in unwords [show x, show y, show (z+1)] : pos1 : getPosValues ((pos1,cmd1):t)

getPosValues ((pos1,_):(pos2,cmd2):t) = pos2 : getPosValues ((pos2,cmd2):t)

-- ################################################################## OUTRAS ####################################################################



beginFile = ["<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"","\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">","<html xmlns=\"http://www.w3.org/1999/xhtml\">","<head>","<meta http-equiv=\"X-UA-Compatible\" content=\"chrome=1\" />", "<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />","<title>Tarefa 2</title>","<script src=\"http://www.x3dom.org/release/x3dom.js\"></script>","<link rel=\"stylesheet\" href=\"http://www.x3dom.org/release/x3dom.css\"/>","</head>","<body>","<h1>Tabuleiro em 3D</h1>","<p class=\"case\">","<X3D xmlns=\"http://www.web3d.org/specifications/x3d-namespace\" id=\"boxes\"","showStat=\"false\" showLog=\"false\" x=\"0px\" y=\"0px\" width=\"400px\" height=\"400px\">","<Scene>","<Background skyColor=\"1 1 1\" />", "<Shape DEF=\"tile\">","<Box size=\".98 .98 .98\"/>","<Appearance>","<Material diffuseColor=\"0 1.0 1.0\"/>","</Appearance>","</Shape>","<Shape DEF=\"tileL\">", "<Box size=\".98 .98 .98\"/>","<Appearance>","<Material diffuseColor=\"0 0 1.0\"/>","</Appearance>","</Shape>","<Transform DEF=\"bonecoT\">","<group DEF=\"boneco\">","<Transform DEF=\"cabeca\" translation=\"0 0 .5\">","<Shape DEF=\"sphereShape\">","<Appearance DEF=\"sphereApp\">","<Material diffuseColor=\"0.96 0.96 0.96\" specularColor=\".5 .5 .5\" />","</Appearance>","<Sphere DEF=\"sphere\" radius=\"0.28\" />","</Shape>","</Transform>","<Transform DEF=\"corpo\" translation=\"0 0 0\">","<Shape DEF=\"sphereShape\">","<Appearance DEF=\"sphereApp\">","<Material diffuseColor=\"0.96 0.96 0.96\" specularColor=\".5 .5 .5\" />","</Appearance>","<Sphere DEF=\"sphere\" radius=\"0.4\" />","</Shape>","</Transform>","<Transform DEF=\"chapeu\" translation=\"0 0 .75\" rotation=\"1 0 0 1.57\">", "<Shape DEF=\"coneShape\">","<Appearance DEF=\"coneApp\">","<Material diffuseColor=\"0.129 0.129 0.129\" specularColor=\".5 .5 .5\" />","</Appearance>","<Cylinder height=\"0.07\" radius=\"0.3\"/>","</Shape>","</Transform>","<Transform DEF=\"chapeu2\" translation=\"0 0 .75\" rotation=\"1 0 0 1.57\">", "<Shape DEF=\"coneShape\">","<Appearance DEF=\"coneApp\">","<Material diffuseColor=\"0.129 0.129 0.129\" specularColor=\".5 .5 .5\" />","</Appearance>","<Cylinder height=\"0.5\" radius= \"0.2\"/>","</Shape>","</Transform>","<Transform DEF=\"nariz\" translation=\"0 .35 .5\" rotation= \"0 0 0 45\">", "<Shape>","<Appearance>","<Material diffuseColor=\"1 0.7 0\" specularColor=\".5 .5 .5\" />","</Appearance>","<Cone DEF=\"cone\" height=\"0.2\" bottomRadius= \"0.1\"/>","</Shape>","</Transform>","</group>","</Transform>"]
endFile = ["<Route fromNode=\"time\" fromField =\"fraction_changed\" toNode=\"move\" toField=\"set_fraction\"> </Route>","<Route fromNode=\"move\" fromField =\"value_changed\" toNode=\"bonecoT\" toField=\"set_translation\"> </Route>","<Route fromNode=\"time\" fromField =\"fraction_changed\" toNode=\"virar\" toField=\"set_fraction\"> </Route>","<Route fromNode=\"virar\" fromField =\"value_changed\" toNode=\"bonecoT\" toField=\"set_rotation\"> </Route>","</Scene>","</X3D>","</p>","<p> &nbsp; </p>","</body>","</html>"]




-- ############################################################### TAREFA 3 (ALTERADA) ###############################################################


{-|
'execCmds' recebe os dados necessários para a execução do jogo: 'Tabuleiro', 'Posicao', 'Comandos'; e os dados respetivos ao estado 
do jogo: ['Lampada'], 'Jogadas'.

Esta função executa os comandos recebidos e devolve uma String do tipo @\"(x,y)\"@  em que (x,y) corresponde à posição da lâmpada no tabuleiro,
 sempre que é acesa\/desligada uma lâmpada.

A função termina a sua execução quando se depara com um dos seguintes casos:

1. recebe uma ['Lampada'] vazia e devolve @\"FIM n\"@, em que @n@ corresponde ao número de "Jogadas".

2. a sequênia de comandos terminou e devolve \"INCOMPLETO\".

/Observação: os casos estão listados pela ordem verificada na função./
-}

execCmds :: Tabuleiro -> Posicao -> Comandos -> [Lampada] -> Jogadas -> [(String,Char)]
execCmds _ _ _ [] nPlays = []
execCmds _ _ [] _ _    = []
execCmds tab pos@(x,y,z,ori) ('A':xs) lamps nPlays | valid = (showPos (x',y',z',ori),'A') : execCmds tab (x',y',z',ori) xs lamps (nPlays+1)
                                                   | otherwise = (showPos (x',y',z',ori),'1') : execCmds tab pos xs lamps nPlays
                                                   where (x',y',z',valid) = avancar tab pos

execCmds tab pos@(x,y,z,ori) ('S':xs) lamps nPlays | saltar tab pos /= (-1,-1,-1,-1) = (showPos (saltar tab pos),'S') : execCmds tab (saltar tab pos) xs lamps (nPlays+1)
                                                   | otherwise = (showPos pos,'2') : execCmds tab pos xs lamps nPlays
                                                   
execCmds tab pos@(x,y,z,ori) ('L':xs) lamps nPlays | isUpper (reverse tab !! y !! x) = (showPos pos,'L') : execCmds tab pos xs (luz pos lamps) (nPlays+1)
                                                   | otherwise = (showPos pos,'3') : execCmds tab pos xs lamps nPlays
                                                 
execCmds tab pos@(x,y,z,ori) (cmd:xs) lamps nPlays = (showPos pos,cmd) : execCmds tab (turn tab pos cmd) xs lamps (nPlays+1)
                      


{-|
'getLamps' recebe um 'Tabuleiro' e dois @Int@ responsáveis por controlar a posição em que a função vai atuar. Esta função percorre o tabuleiro,
entrada a entrada, e reúne as posições de todos as lâmpadas presentes no tabuleiro, devolvendo uma ['Lampada'].
-}

getLamps :: Tabuleiro -> Int -> [Lampada]
getLamps [] _ = []
getLamps (h:t) n = checkLine h (n,0) ++ getLamps t (n+1)

         where checkLine [] _ = []
               checkLine (h:t) (n,m) | isUpper h = (m,n) : checkLine t (n,m+1)
                                     | otherwise = checkLine t (n,m+1)



{-|
'luz' verifica se a lâmpada existente na 'Posicao' recebida se encontra na ['Lampada'], que conté a lista de lâmpadas apagadas. Esta função devolve 
uma ["Lampada"] em que:

*caso a lâmpada não pertença à lista é devolvido uma lista com a lâmpada.

*caso a lâmpada pertença à lista é devolvido uma lista sem a lâmpada.
-}
luz :: Posicao -> [Lampada] -> [Lampada]
luz (x,y,z,ori) lamps | lamp == [] = (x,y):resto -- se a lampada estiver acesa -> apaga a lampada
                         | otherwise  = resto       -- se a lampada estiver apagada -> Liga a lampada
                  
                  where (lamp,resto) = partition (\ (xL,yL) -> (xL == x) && (yL == y)) lamps -- verifica se a lampada está apagada

{-|
'doCmd' recebe os dados necessários à execução do comando, 'Tabuleiro' e 'Posicao', o comando, e devolve a posição originada pela execução do comando 
 recebido.
-}

turn :: Tabuleiro -> Posicao -> Char -> Posicao
turn tab pos 'E' = esq pos
turn tab pos 'D' = dir pos




{-| 
'esq' recebe uma 'Posicao' e devolve como resultado uma nova 'Posicao' na qual a orientação assumida pelo Robot é girada 90º para a esquerda 
de acordo com os pontos cardeais.
-}

esq :: Posicao -> Posicao                                            
esq (x,y,z,0)    = (x,y,z,1.57)
esq (x,y,z,1.57) = (x,y,z,3.14)
esq (x,y,z,3.14) = (x,y,z,-1.57)
esq (x,y,z,-1.57) = (x,y,z,0)



{-| 
'dir' recebe uma "Posicao" e devolve uma nova "Posicao" na qual a orientação assumida pelo Robot é girada 90º para a direita 
de acordo com os pontos cardeais.
-}

dir :: Posicao -> Posicao                                            
dir (x,y,z,0)     = (x,y,z,-1.57)
dir (x,y,z,-1.57)  = (x,y,z,3.14)
dir (x,y,z,3.14)  = (x,y,z,1.57)
dir (x,y,z,1.57) = (x,y,z,0)


{-|
'saltar' recebe um 'Tabuleiro' e uma 'Posicao' e devolve a nova 'Posicao' assumida pelo Robot após este saltar no tabuleiro de acordo com a sua
orientação.

Para que a execução do comando 'saltar' seja uma ação válida as seguintes condições devem ser cumpridas:

* a nova posição deve continuar dentro dos limites do tabuleiro;

* a nova posição deve ser um nível superior à posição dada OU a nova posição deve ser inferior à posição dada;

Caso uma destas condições não seja cumprida é devolvida @[]@.
-}

saltar :: Tabuleiro -> Posicao -> Posicao
saltar tab (x,y,z,ori) | (z' < z) && (z' >= 1) = (x',y',z',ori) 
                       | (z' == z+1) = (x',y',z',ori)
                       | otherwise = (-1,-1,-1,-1)
               
                        where (x',y',z') = getNextS tab (x,y,z,ori)

getNextS :: Tabuleiro -> Posicao -> (Int, Int,Int)
getNextS tab (x,y,z,ori) | (ori == 0)     && (y+1 < n)   = (x, y+1, ord (toLower (reverse tab !! (y+1) !! x)) - ord 'a' + 1)
                         | (ori == 3.14)  && (y-1 >= 0)  = (x, y-1, ord (toLower (reverse tab !! (y-1) !! x)) - ord 'a' + 1)
                         | (ori == 1.57)  && (x-1 >= 0)  = (x-1, y, ord (toLower (reverse tab !! y !! (x-1))) - ord 'a' + 1)
                         | (ori == -1.57) && (x+1 < m)   = (x+1, y, ord (toLower (reverse tab !! y !! (x+1))) - ord 'a' + 1)
                         | otherwise = (-1, -1, -1) 

                where n = length tab
                      m = length (head (tab))

avancar :: Tabuleiro -> Posicao -> (Int,Int,Int,Bool) 
avancar tab (x,y,z,ori) | validPos tab (x',y',z') && getZ tab (x',y',z',ori) == z = (x',y',z',True)
                        | validPos tab (x',y',z') = (x',y',z',False)
                        | otherwise = (x',y',z,False)
                  
                where (x',y',z') = getNextA tab (x,y,z,ori)


getNextA :: Tabuleiro -> Posicao -> (Int,Int,Int)
getNextA tab (x,y,z,ori) | (ori == 0)     = (x, y+1, z)
                         | (ori == 3.14)  = (x, y-1, z)
                         | (ori == 1.57)  = (x-1, y, z)
                         | (ori == -1.57) = (x+1, y, z)





-- | 'getZ' recebe um 'Tabuleiro' e uma 'Posicao' e devolve como resultado o 'Nivel' da posição em que o robot se encontra no tabuleiro.

getZ :: Tabuleiro -> Posicao -> Int
getZ tab (x,y,_,_) = ord (toLower (reverse tab !! y !! x)) - (ord 'a') + 1



validPos :: Tabuleiro -> (Int,Int,Int) -> Bool
validPos tab (x,y,_) = let n = length tab
                           m = length (head tab)
                        in (y < n) && (y >= 0) && (x >= 0) && (x < m)

getPos :: Tabuleiro -> String -> Posicao
getPos tab strPos = let [strX,strY,[oriC]] = words strPos
                        x = read strX :: Int
                        y = read strY :: Int
                        z = ord (reverse tab !! y !! x) - ord 'a' + 1
                        ori = getOri oriC
                     in (x,y,z,ori)

getOri :: Char -> Float
getOri 'N' = 0
getOri 'S' = 3.14
getOri 'E' = -1.57
getOri 'O' = 1.57


showPos :: Posicao -> String
showPos (x,y,z,_) = unwords [show x,show y, show z]