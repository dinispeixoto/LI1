module Main where

import Data.Char

type Tabuleiro = [String]
type Posicao = String
type Lampada = (Int,Int)
type Comandos = String
type Jogadas = Int
type Nivel = Char

outStr :: [String] -> String
outStr [] = "\n"
outStr t = unlines t

main = do input <- getContents
          putStr (outStr (setUp (lines input)))

setUp :: [String] -> [String]
setUp input = execCmds tab pos cmd lampList 0
              where tab = take (length input-2) input
                    pos = input !! (length input-2)
                    cmd = input !! (length input-1)
                    lampList = getLampadas (reverse tab) 0 0

execCmds :: Tabuleiro -> Posicao -> Comandos -> [Lampada] -> Jogadas -> [String]
execCmds _ _ _ [] nPlays = ("FIM "++(show nPlays)):[]
execCmds _ _ [] _ _    = "INCOMPLETO":[]

execCmds tab pos (cmd:xs) lampList nPlays | (elem cmd "EDAS") && (doCmd tab pos cmd /= [])  = execCmds tab (doCmd tab pos cmd) xs lampList (nPlays+1)
                                          | (cmd == 'L') && (isUpper posLevel)              = posLamp:execCmds tab pos xs (luz pos lampList) (nPlays+1)
                                          | otherwise                                       = execCmds tab pos xs lampList nPlays
                                            where posLevel = getPos tab pos
                                                  posLamp = unwords [(words pos !! 0),(words pos !! 1)]

getLampadas :: Tabuleiro -> Int -> Int -> [Lampada]
getLampadas [] _ _ = []
getLampadas (h:t) n m | (isUpper x) && (xs == [])    = (m,n):getLampadas t (n+1) 0
                      | not(isUpper x) && (xs == []) = getLampadas t (n+1) 0
                      | isUpper x                    = (m,n):(getLampadas (xs:t) n (m+1))
                      | not(isUpper x)               = getLampadas (xs:t) n (m+1)
                       where (x:xs) = h

luz :: Posicao -> [Lampada] -> [Lampada]
luz pos lampList | lamp == [] = (x,y):newLampList -- se a lampada estiver acesa -> apaga a lampada
                 | lamp /= [] = newLampList       -- se a lampada estiver apagada -> Liga a lampada
                  where x = read ((words pos) !! 0) :: Int
                        y = read ((words pos) !! 1) :: Int
                        lamp = filter (\ (xL,yL) -> (xL == x) && (yL == y)) lampList -- verifica se a lampada está apagada
                        newLampList = filter (\ (xL,yL) -> (xL /= x) || (yL /= y)) lampList


doCmd :: Tabuleiro -> Posicao -> Char -> Posicao
doCmd tab pos cmd | (cmd == 'A') = avancar tab pos
                  | (cmd == 'S') = saltar tab pos
                  | (cmd == 'E') = esq pos
                  | (cmd == 'D') = dir pos

esq :: Posicao -> Posicao                                             -- Comando: Esquerda
esq pos | (ori == "N") = unwords (coords ++ ["O"])
        | (ori == "O") = unwords (coords ++ ["S"])
        | (ori == "S") = unwords (coords ++ ["E"])
        | (ori == "E") = unwords (coords ++ ["N"])
           where posL = words pos
                 ori = posL !! 2
                 coords = [(posL !! 0),(posL !! 1)]

dir :: Posicao -> Posicao                                             -- Comando: Direita
dir pos | (ori == "N") = unwords (coords ++ ["E"])
        | (ori == "E") = unwords (coords ++ ["S"])
        | (ori == "S") = unwords (coords ++ ["O"])
        | (ori == "O") = unwords (coords ++ ["N"])
          where posL = words pos
                ori = posL !! 2
                coords = [(posL !! 0),(posL !! 1)]

avancar :: Tabuleiro -> Posicao -> Posicao                            -- Comando: Avançar
avancar tab pos | (nivelIni == proxNivel) = unwords newPos
                | otherwise = []
                  where nivelIni = toLower(getPos tab pos)
                        (proxNivel, x, y, ori) = getNext tab pos
                        newPos = [(show x),(show y),ori]

saltar :: Tabuleiro -> Posicao -> Posicao
saltar tab pos | (proxLevel < level) && (proxLevel >= 'a') = unwords newPos 
               | (proxLevel == nLevel) = unwords newPos
               | otherwise = []
                 where (proxLevel, x, y, ori) = getNext tab pos
                       newPos = [(show x),(show y),ori]
                       level = toLower (getPos tab pos)
                       pLevel = chr (ord level - 1)
                       nLevel = chr (ord level + 1)

getPos :: Tabuleiro -> Posicao -> Nivel
getPos tab pos = (newTab !! y) !! x
                     where newTab = reverse tab
                           posL = words pos
                           x = (read (posL !! 0) :: Int)
                           y = (read (posL !! 1) :: Int)

getNext :: Tabuleiro -> Posicao -> (Nivel, Int,Int, String)
getNext tab pos | (ori == "N") && (y+1 < n)   = (toLower((nMap !! ((y+1)) !! x)), x, y+1, "N")
                | (ori == "S") && (y-1 >= 0)  = (toLower((nMap !! ((y-1)) !! x)), x, y-1, "S")
                | (ori == "O") && (x-1 >= 0)  = (toLower((nMap !! y) !! (x-1)), x-1, y, "O")
                | (ori == "E") && (x+1 < m)   = (toLower((nMap !! y) !! (x+1)), x+1, y, "E")
                | otherwise = (' ', -1, -1, [])
                   where nMap = reverse tab
                         posL = words pos
                         x = (read (posL !! 0) :: Int)
                         y = (read (posL !! 1) :: Int)
                         ori = posL !! 2
                         n = length tab
                         m = length (head (tab))