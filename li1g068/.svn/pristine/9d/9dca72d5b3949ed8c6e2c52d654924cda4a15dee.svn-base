module Main where

import Data.Char
import Data.List

type Tabuleiro = [String]
type Posicao = (Int,Int)
type Orientacao = Char
type Lampada = (Int,Int)
type Cmd = Char

main = do input <- getContents
          putStrLn (setUp (lines input))

setUp :: [String] -> String
setUp input = toString ori (allLamps tab pos ori (-1,-1) lamps)
              where tab = init input
                    (pos, ori) = strToPos ( words (last input) )
                    lamps = getLampadas (reverse tab) 0 0

allLamps :: Tabuleiro -> Posicao -> Orientacao -> Posicao -> [Lampada] -> [(Posicao,Orientacao,Cmd)]
allLamps _ _ _ _ [] = []
allLamps tab pos ori lastPos lamps = result ++ (allLamps tab posL oriL (-1,-1) (delete posL lamps))

                                   where lamp = closerLamp pos lamps
                                         paths = getPaths tab pos ori lamp lastPos
                                         result = followPath tab paths pos lamps
                                         (posL,oriL,_) = last result

followPath :: Tabuleiro -> [(Posicao,Orientacao,Cmd)] -> Posicao -> [Lampada] -> [(Posicao,Orientacao,Cmd)]
followPath _ [] _ _ = [((-1,-1),' ',' ')]
followPath tab ((pos,ori,cmd):t) lastPos lamps | pos == lamp = [(pos,ori,cmd),(pos,ori,'L')]
                                               | followPath tab paths pos lamps /= [((-1,-1),' ',' ')] = (pos,ori,cmd) : followPath tab paths pos lamps
                                               | otherwise = followPath tab t lastPos lamps


                    where lamp = closerLamp pos lamps
                          paths = getPaths tab pos ori lamp lastPos


getPaths :: Tabuleiro -> Posicao -> Orientacao -> Lampada -> Posicao -> [(Posicao,Orientacao,Cmd)]
getPaths tab (x,y) ori (xL,yL) lastPos = let options = [((x+1,y),'E'),((x-1,y),'O'),((x,y+1),'N'),((x,y-1),'S')]
                                             onTab = filter (\ ((xT,yT),_) -> (xT >= 0) && (yT >= 0) && (xT < length (head tab)) && (yT < length tab)) options
                                             withCmd = map (\ (newPos,newOri) -> (newPos,newOri,getCmds tab (x,y) newPos)) onTab

                                             paths = filter (\ (newPos,_,cmd) -> cmd /= '!' && newPos /= lastPos) withCmd

                                             diff = (xL-x,yL-y)

                                          in optimal (xL,yL) diff ori paths

optimal :: Lampada -> Posicao -> Orientacao -> [(Posicao,Orientacao,Cmd)] -> [(Posicao,Orientacao,Cmd)]
optimal lamp diff ori paths = let sameOri = find (\ (_,ori2,_) -> ori == ori2) paths
                                  paths' = toPosOri sameOri paths
                                  (otimos,outros) = partition (\ (pos,_,_) -> optimalPaths lamp pos diff) paths'
                               in otimos ++ outros  



toPosOri :: Maybe (Posicao,Orientacao,Cmd) -> [(Posicao,Orientacao,Cmd)] -> [(Posicao,Orientacao,Cmd)]
toPosOri Nothing paths = paths
toPosOri (Just sameOri) paths = sameOri : (delete sameOri paths)

optimalPaths :: Lampada -> Posicao -> Posicao -> Bool
optimalPaths (xL,yL) (nX,nY) (dX,dY) | dX > 0 && xL - nX < dX = True
                                     | dX < 0 && xL - nX > dX = True
                                     | dY > 0 && yL - nY < dY = True
                                     | dY < 0 && yL - nY > dY = True
                                     | otherwise = False


getCmds :: Tabuleiro -> Posicao -> Posicao -> Cmd
getCmds tab (x1,y1) (x2,y2) | cell1 > cell2 = 'S'
                            | succ cell1 == cell2 = 'S'
                            | cell1 == cell2 = 'A'
                            | otherwise = '!'
                                   
                                 where cell1 = toLower ((reverse tab) !! y1 !! x1)
                                       cell2 = toLower ((reverse tab) !! y2 !! x2)



getLampadas :: Tabuleiro -> Int -> Int -> [Lampada]
getLampadas [] _ _ = []
getLampadas ((x:xs):t) n m | (isUpper x) && (xs == [])    = (m,n):getLampadas t (n+1) 0  
                           | not(isUpper x) && (xs == []) = getLampadas t (n+1) 0         
                           | isUpper x                    = (m,n):getLampadas (xs:t) n (m+1)
                           | not(isUpper x)               = getLampadas (xs:t) n (m+1)


toString :: Orientacao -> [(Posicao, Orientacao, Cmd)] -> String
toString _ [] = []
toString oriI ((_,oriF,cmd):t) = (getTurning oriI oriF) ++ [cmd] ++ toString oriF t

                      
-- ######################################################### AUXILIARES ##########################################################################

strToPos :: [String] -> (Posicao,Orientacao)
strToPos [x,y,[o]] = ( (read x :: Int, read y :: Int), o)

dist :: (Int,Int) -> (Int,Int) -> Int
dist (x1,y1) (x2,y2) = (abs(x2-x1)) + (abs (y2-y1))

closerLamp :: Posicao -> [Lampada] -> Lampada
closerLamp pos lamps = let min = minimum (map (\ lamp -> dist pos lamp) lamps)
                        in head (filter (\ lamp -> dist pos lamp == min) lamps)

getTurning :: Orientacao -> Orientacao -> [Cmd]
getTurning o o2 | o == o2 = [] 
                | (o == 'S' && o2 == 'N') || (o == 'N' && o2 == 'S') || (o == 'E' && o2 == 'O') || (o == 'O' && o2 == 'E') = "DD"
                | (o == 'N' && o2 == 'E') || (o == 'E' && o2 == 'S') || (o == 'S' && o2 == 'O') || (o == 'O' && o2 == 'N') = "D"
                | (o == 'N' && o2 == 'O') || (o == 'O' && o2 == 'S') || (o == 'S' && o2 == 'E') || (o == 'E' && o2 == 'N') = "E"